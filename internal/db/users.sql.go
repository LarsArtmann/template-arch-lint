//go:build sqlite3

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/LarsArtmann/template-arch-lint/internal/domain/values"
)

const BulkDeleteUsers = `-- name: BulkDeleteUsers :exec
DELETE FROM users WHERE id = ?
`

// BulkDeleteUsers
//
//	DELETE FROM users WHERE id = ?
func (q *Queries) BulkDeleteUsers(ctx context.Context, id values.UserID) error {
	_, err := q.exec(ctx, q.bulkDeleteUsersStmt, BulkDeleteUsers, id)
	return err
}

const BulkInsertUsers = `-- name: BulkInsertUsers :exec

INSERT OR IGNORE INTO users (id, email, name, created, modified)
VALUES (?, ?, ?, ?, ?)
`

type BulkInsertUsersParams struct {
	ID       values.UserID `db:"id" json:"id"`
	Email    string        `db:"email" json:"email"`
	Name     string        `db:"name" json:"name"`
	Created  time.Time     `db:"created" json:"created"`
	Modified time.Time     `db:"modified" json:"modified"`
}

// Bulk operations for performance
//
//	INSERT OR IGNORE INTO users (id, email, name, created, modified)
//	VALUES (?, ?, ?, ?, ?)
func (q *Queries) BulkInsertUsers(ctx context.Context, arg *BulkInsertUsersParams) error {
	_, err := q.exec(ctx, q.bulkInsertUsersStmt, BulkInsertUsers,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Created,
		arg.Modified,
	)
	return err
}

const CountUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

// CountUsers
//
//	SELECT COUNT(*) FROM users
func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countUsersStmt, CountUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUsersByDateRange = `-- name: CountUsersByDateRange :one
SELECT COUNT(*) FROM users
WHERE created BETWEEN ? AND ?
`

type CountUsersByDateRangeParams struct {
	FromCreated time.Time `db:"from_created" json:"fromCreated"`
	ToCreated   time.Time `db:"to_created" json:"toCreated"`
}

// CountUsersByDateRange
//
//	SELECT COUNT(*) FROM users
//	WHERE created BETWEEN ? AND ?
func (q *Queries) CountUsersByDateRange(ctx context.Context, arg *CountUsersByDateRangeParams) (int64, error) {
	row := q.queryRow(ctx, q.countUsersByDateRangeStmt, CountUsersByDateRange, arg.FromCreated, arg.ToCreated)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

// DeleteUser
//
//	DELETE FROM users WHERE id = ?
func (q *Queries) DeleteUser(ctx context.Context, id values.UserID) error {
	_, err := q.exec(ctx, q.deleteUserStmt, DeleteUser, id)
	return err
}

const FindRecentUsers = `-- name: FindRecentUsers :many

SELECT id, email, name, created, modified
FROM users
WHERE created > datetime('now', '-30 days')
ORDER BY created DESC
LIMIT ? OFFSET ?
`

type FindRecentUsersParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

// Performance-optimized queries
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE created > datetime('now', '-30 days')
//	ORDER BY created DESC
//	LIMIT ? OFFSET ?
func (q *Queries) FindRecentUsers(ctx context.Context, arg *FindRecentUsersParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.findRecentUsersStmt, FindRecentUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FindUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, name, created, modified
FROM users
WHERE email = ?
LIMIT 1
`

// FindUserByEmail
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE email = ?
//	LIMIT 1
func (q *Queries) FindUserByEmail(ctx context.Context, email string) (*Users, error) {
	row := q.queryRow(ctx, q.findUserByEmailStmt, FindUserByEmail, email)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Created,
		&i.Modified,
	)
	return &i, err
}

const FindUserByID = `-- name: FindUserByID :one
SELECT id, email, name, created, modified
FROM users
WHERE id = ?
LIMIT 1
`

// FindUserByID
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE id = ?
//	LIMIT 1
func (q *Queries) FindUserByID(ctx context.Context, id values.UserID) (*Users, error) {
	row := q.queryRow(ctx, q.findUserByIDStmt, FindUserByID, id)
	var i Users
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Created,
		&i.Modified,
	)
	return &i, err
}

const GetActiveUserEmails = `-- name: GetActiveUserEmails :many
SELECT DISTINCT email
FROM users
WHERE modified > datetime('now', '-7 days')
ORDER BY email
`

// GetActiveUserEmails
//
//	SELECT DISTINCT email
//	FROM users
//	WHERE modified > datetime('now', '-7 days')
//	ORDER BY email
func (q *Queries) GetActiveUserEmails(ctx context.Context) ([]string, error) {
	rows, err := q.query(ctx, q.getActiveUserEmailsStmt, GetActiveUserEmails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetQueryPlan = `-- name: GetQueryPlan :many
EXPLAIN QUERY PLAN SELECT id, email, name, created, modified FROM users WHERE email = ?
`

// GetQueryPlan
//
//	EXPLAIN QUERY PLAN SELECT id, email, name, created, modified FROM users WHERE email = ?
func (q *Queries) GetQueryPlan(ctx context.Context, email string) ([]*Users, error) {
	rows, err := q.query(ctx, q.getQueryPlanStmt, GetQueryPlan, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserStats = `-- name: GetUserStats :one
SELECT
    COUNT(*) as total_users,
    COUNT(CASE WHEN created > datetime('now', '-1 day') THEN 1 END) as users_today,
    COUNT(CASE WHEN created > datetime('now', '-7 days') THEN 1 END) as users_week,
    COUNT(CASE WHEN created > datetime('now', '-30 days') THEN 1 END) as users_month,
    CAST(COALESCE(MIN(created), '1900-01-01 00:00:00') AS TEXT) as first_user_created,
    CAST(COALESCE(MAX(created), '1900-01-01 00:00:00') AS TEXT) as last_user_created
FROM users
`

type GetUserStatsRow struct {
	TotalUsers       int64  `db:"total_users" json:"totalUsers"`
	UsersToday       int64  `db:"users_today" json:"usersToday"`
	UsersWeek        int64  `db:"users_week" json:"usersWeek"`
	UsersMonth       int64  `db:"users_month" json:"usersMonth"`
	FirstUserCreated string `db:"first_user_created" json:"firstUserCreated"`
	LastUserCreated  string `db:"last_user_created" json:"lastUserCreated"`
}

// GetUserStats
//
//	SELECT
//	    COUNT(*) as total_users,
//	    COUNT(CASE WHEN created > datetime('now', '-1 day') THEN 1 END) as users_today,
//	    COUNT(CASE WHEN created > datetime('now', '-7 days') THEN 1 END) as users_week,
//	    COUNT(CASE WHEN created > datetime('now', '-30 days') THEN 1 END) as users_month,
//	    CAST(COALESCE(MIN(created), '1900-01-01 00:00:00') AS TEXT) as first_user_created,
//	    CAST(COALESCE(MAX(created), '1900-01-01 00:00:00') AS TEXT) as last_user_created
//	FROM users
func (q *Queries) GetUserStats(ctx context.Context) (*GetUserStatsRow, error) {
	row := q.queryRow(ctx, q.getUserStatsStmt, GetUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.UsersToday,
		&i.UsersWeek,
		&i.UsersMonth,
		&i.FirstUserCreated,
		&i.LastUserCreated,
	)
	return &i, err
}

const GetUsersCreatedAfter = `-- name: GetUsersCreatedAfter :many
SELECT id, email, name, created, modified
FROM users
WHERE created >= ?
ORDER BY created DESC
LIMIT ? OFFSET ?
`

type GetUsersCreatedAfterParams struct {
	Created time.Time `db:"created" json:"created"`
	Limit   int64     `db:"limit" json:"limit"`
	Offset  int64     `db:"offset" json:"offset"`
}

// GetUsersCreatedAfter
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE created >= ?
//	ORDER BY created DESC
//	LIMIT ? OFFSET ?
func (q *Queries) GetUsersCreatedAfter(ctx context.Context, arg *GetUsersCreatedAfterParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.getUsersCreatedAfterStmt, GetUsersCreatedAfter, arg.Created, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersModifiedAfter = `-- name: GetUsersModifiedAfter :many
SELECT id, email, name, created, modified
FROM users
WHERE modified >= ?
ORDER BY modified DESC
LIMIT ? OFFSET ?
`

type GetUsersModifiedAfterParams struct {
	Modified time.Time `db:"modified" json:"modified"`
	Limit    int64     `db:"limit" json:"limit"`
	Offset   int64     `db:"offset" json:"offset"`
}

// GetUsersModifiedAfter
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE modified >= ?
//	ORDER BY modified DESC
//	LIMIT ? OFFSET ?
func (q *Queries) GetUsersModifiedAfter(ctx context.Context, arg *GetUsersModifiedAfterParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.getUsersModifiedAfterStmt, GetUsersModifiedAfter, arg.Modified, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsers = `-- name: ListUsers :many
SELECT id, email, name, created, modified
FROM users
ORDER BY created DESC
LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

// ListUsers
//
//	SELECT id, email, name, created, modified
//	FROM users
//	ORDER BY created DESC
//	LIMIT ? OFFSET ?
func (q *Queries) ListUsers(ctx context.Context, arg *ListUsersParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.listUsersStmt, ListUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsersAll = `-- name: ListUsersAll :many
SELECT id, email, name, created, modified
FROM users
ORDER BY created DESC
`

// ListUsersAll
//
//	SELECT id, email, name, created, modified
//	FROM users
//	ORDER BY created DESC
func (q *Queries) ListUsersAll(ctx context.Context) ([]*Users, error) {
	rows, err := q.query(ctx, q.listUsersAllStmt, ListUsersAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SaveUser = `-- name: SaveUser :exec

INSERT OR REPLACE INTO users (id, email, name, created, modified)
VALUES (?, ?, ?, ?, ?)
`

type SaveUserParams struct {
	ID       values.UserID `db:"id" json:"id"`
	Email    string        `db:"email" json:"email"`
	Name     string        `db:"name" json:"name"`
	Created  time.Time     `db:"created" json:"created"`
	Modified time.Time     `db:"modified" json:"modified"`
}

// Users CRUD queries
// Optimized for performance with proper indexing and query patterns
//
//	INSERT OR REPLACE INTO users (id, email, name, created, modified)
//	VALUES (?, ?, ?, ?, ?)
func (q *Queries) SaveUser(ctx context.Context, arg *SaveUserParams) error {
	_, err := q.exec(ctx, q.saveUserStmt, SaveUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Created,
		arg.Modified,
	)
	return err
}

const SearchUsersByEmail = `-- name: SearchUsersByEmail :many
SELECT id, email, name, created, modified
FROM users
WHERE email LIKE '%' || ? || '%'
ORDER BY email
LIMIT ? OFFSET ?
`

type SearchUsersByEmailParams struct {
	Column1 sql.NullString `db:"column_1" json:"column1"`
	Limit   int64          `db:"limit" json:"limit"`
	Offset  int64          `db:"offset" json:"offset"`
}

// SearchUsersByEmail
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE email LIKE '%' || ? || '%'
//	ORDER BY email
//	LIMIT ? OFFSET ?
func (q *Queries) SearchUsersByEmail(ctx context.Context, arg *SearchUsersByEmailParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.searchUsersByEmailStmt, SearchUsersByEmail, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchUsersByName = `-- name: SearchUsersByName :many
SELECT id, email, name, created, modified
FROM users
WHERE name LIKE '%' || ? || '%'
ORDER BY name
LIMIT ? OFFSET ?
`

type SearchUsersByNameParams struct {
	Column1 sql.NullString `db:"column_1" json:"column1"`
	Limit   int64          `db:"limit" json:"limit"`
	Offset  int64          `db:"offset" json:"offset"`
}

// SearchUsersByName
//
//	SELECT id, email, name, created, modified
//	FROM users
//	WHERE name LIKE '%' || ? || '%'
//	ORDER BY name
//	LIMIT ? OFFSET ?
func (q *Queries) SearchUsersByName(ctx context.Context, arg *SearchUsersByNameParams) ([]*Users, error) {
	rows, err := q.query(ctx, q.searchUsersByNameStmt, SearchUsersByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Users{}
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUserModified = `-- name: UpdateUserModified :exec
UPDATE users
SET modified = CURRENT_TIMESTAMP
WHERE id = ?
`

// UpdateUserModified
//
//	UPDATE users
//	SET modified = CURRENT_TIMESTAMP
//	WHERE id = ?
func (q *Queries) UpdateUserModified(ctx context.Context, id values.UserID) error {
	_, err := q.exec(ctx, q.updateUserModifiedStmt, UpdateUserModified, id)
	return err
}
